//===- symbolization.dl -----------------------------------------*- datalog -*-===//
//
//  Copyright (C) 2019 GrammaTech, Inc.
//
//  This code is licensed under the GNU Affero General Public License
//  as published by the Free Software Foundation, either version 3 of
//  the License, or (at your option) any later version. See the
//  LICENSE.txt file in the project root for license terms or visit
//  https://www.gnu.org/licenses/agpl.txt.
//
//  This program is distributed in the hope that it will be useful,
//  but WITHOUT ANY WARRANTY; without even the implied warranty of
//  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
//  GNU Affero General Public License for more details.
//
//  This project is sponsored by the Office of Naval Research, One Liberty
//  Center, 875 N. Randolph Street, Arlington, VA 22203 under contract #
//  N68335-17-C-0700.  The content of the information does not necessarily
//  reflect the position or policy of the Government and no official
//  endorsement should be inferred.
//
//===----------------------------------------------------------------------===//
/**
This module performs symbolization.
It uses the results of several analysis:
 -use_def
 -value
 -data_access

Part of symbolization is pointer reatribution, that is detecting cases
where a number is the result of a symbol+constant. This is done in an
independent module 'pointer_reatribution' which also uses the results
of these analyses.

The data symbolization itself uses the following heuristics:

  - address_array: whether we have potential symbols evenly
    spaced. The more symbols the less likely they are all value
    collisions. We require at least 3 symbols evenly spaced to
    consider it an array.

  - preferred_data_access and data_access_patterns (from the data_access analysis):
    - if an address is accessed with the size of the pointer, it is more likely to be a pointer.
    - if an address is accessed with a size other than the size of the pointers, it is almost
      certainly not a pointer.

  - strings: if we have a pointer candidate in what seems to be a string,
    it is less likely to be a pointer.

  - aligned location: if a pointer candidate is aligned, it is more
    likely to be a pointer. Compilers usually (but not always) store
    pointers aligned.

This module also computes and symbol_minus_symbol.
*/

#include "empty_range.dl"
#include "bitmasks.dl"
#include "use_def_analysis.dl"
#include "value_analysis.dl"
#include "data_access_analysis.dl" // data_access_analysis uses predicates from here
#include "pointer_reatribution.dl"

.decl symbolic_operand(ea:address,index:operand_index,value:address,type:symbol)
.output symbolic_operand

.decl symbolic_data(ea:address,size:number,value:address)
.output symbolic_data

// Symbolic expression generated from relocations
.decl symbolic_expr_from_relocation(ea:address,size:number,symbol:symbol,Addend:number)
.output symbolic_expr_from_relocation

.decl symbol_minus_symbol_candidate(ea:address,size:number,symbol1:address,symbol2:address,Reference:symbol)
.output symbol_minus_symbol_candidate

.decl symbol_minus_symbol(ea:address,size:number,symbol1:address,symbol2:address)
.output symbol_minus_symbol

// symbolic data that points to code
.decl code_pointer_in_data(EA:address,Val:address)

// data that is dereferenced somewhere in the code
.decl labeled_data(ea:address)
.output labeled_data

// labels of un-initialized data
.decl bss_data(ea:address)
.output bss_data

// string
.decl string_candidate(ea:address,end:address)

.decl string(ea:address,end:address)
.output string

.decl heuristic_weight(Name:symbol,Weight:number)
.decl default_heuristic_weight(Name:symbol,Weight:number)
.decl user_heuristic_weight(Name:symbol,Weight:number)
.input user_heuristic_weight

heuristic_weight(Name,Weight):-
    user_heuristic_weight(Name,Weight).
heuristic_weight(Name,Weight):-
    !user_heuristic_weight(Name,_),
    default_heuristic_weight(Name,Weight).
////////////////////////////////////////////////////////////////////////////////////
// candidates of symbolic values in the code

.decl symbolic_operand_candidate(ea:address,operand_index:number,Dest:address,Type:symbol)
.decl symbolic_operand_point(ea:address,operand_index:number,points:number,why:symbol)
.output symbolic_operand_point
.decl symbolic_operand_total_points(ea:address,operand_index:number,points:number)

symbolic_operand_candidate(EA,Op_index,Dest,Type):-
  binary_type("EXEC"),
    code(EA),
    instruction_get_op(EA,Op_index,Op),
    (
        op_immediate(Op,Dest);
        pc_relative_operand(EA,Op_index,Dest);
        op_indirect(Op,_,_,_,_,Dest,_),
        !pc_relative_operand(EA,Op_index,_)
    ),
    (
        code(Dest), Type="code"
        ;
        data_segment(Begin,End),
        Dest >= Begin, Dest <= End,
        Type = "data"
    ).

// Deal with pie and relocatable code
symbolic_operand_candidate(EA,Op_index,Dest,Type):-
  !binary_type("EXEC"),
    code(EA),
    (
        instruction_immediate_offset(EA,Op_index,ImmediateOffset),
        relocation(EA+ImmediateOffset,_,Symbol,Addend),
        symbol(SymbolAddr,_,_,_,_,Symbol),
        Dest = SymbolAddr+Addend
        ;
        instruction_displacement_offset(EA,Op_index,DisplacementOffset),
        relocation(EA+DisplacementOffset,_,Symbol,Addend),
        symbol(SymbolAddr,_,_,_,_,Symbol),
        Dest = SymbolAddr+Addend
        ;
        direct_call(EA,Dest),
        Op_index = 1
        ;
        direct_jump(EA,Dest),
        //ignore artificial jumps from loop instructions/prefix
        instruction_get_operation(EA,Operation),
        arch.jump_operation(Operation),
        Op_index = 1
        ;
        pc_relative_operand(EA,Op_index,Dest)
    ),
    (
        code(Dest), Type = "code"
        ;
        data_segment(Begin,End),
        Dest >= Begin,
        Dest <= End,
        Type = "data"
    ).

/////////////////////////////////////////////////////////////////
/// Final decision on symbolization of operands

default_heuristic_weight("operand bias",0).
default_heuristic_weight("operand has relocation",10).
default_heuristic_weight("compared to non-address",-1).
default_heuristic_weight("immediate is bitmask",-1).
default_heuristic_weight("operand point-to-exception-section",-2).
default_heuristic_weight("operated on logical operation result",-1).
default_heuristic_weight("moved/compared with different size",-1).
default_heuristic_weight("used-for-address",1).

symbolic_operand_point(EA,Index,Points,"operand bias"):-
    symbolic_operand_candidate(EA,Index,_,_),
    heuristic_weight("operand bias",Points).

// no decision needs to be made with pie code
symbolic_operand_point(EA,Index,Points,"operand has relocation"):-
    !binary_type("EXEC"),
    symbolic_operand_candidate(EA,Index,_,_),
    heuristic_weight("operand has relocation",Points).

symbolic_operand_point(EA,Imm_index,Points,"compared to non-address"):-
    cmp_immediate_to_reg(EA,Reg,Imm_index,_),
    def_used(EA_def,Reg,EA,_),
    def_used(EA_def,Reg,EA2,_), EA2 != EA,
    cmp_immediate_to_reg(EA2,Reg,Imm_index2,_),
    !symbolic_operand_candidate(EA2,Imm_index2,_,_),
    heuristic_weight("compared to non-address",Points).

symbolic_operand_point(EA,Imm_index,Points,"immediate is bitmask"):-
    symbolic_operand_candidate(EA,Imm_index,_,_),
    instruction_get_op(EA,Imm_index,Op),
    op_immediate(Op,_),
    instruction_get_operation(EA,Operation),
    arch.logic_operation(Operation),
    heuristic_weight("immediate is bitmask",Points).

symbolic_operand_point(EA,Imm_index,Points,"operand point-to-exception-section"):-
    symbolic_operand_candidate(EA,Imm_index,Dest,_),
    exception_section(Name),
    section(Name,SectSize,Base),
    Base <= Dest, Dest < Base+SectSize,
    heuristic_weight("operand point-to-exception-section",Points).

 symbolic_operand_point(EA,Imm_index,Points,"operated on logical operation result"):-
    op_immediate_and_reg(EA,_,Reg,Imm_index,_),
    def_used(EA_def,Reg,EA,_),
    instruction_get_operation(EA_def,Operation),
    arch.logic_operation(Operation),
    !low_pass_filter(EA_def),
    !is_xor_reset(EA_def),
    heuristic_weight("operated on logical operation result",Points).

symbolic_operand_point(EA,Op_index,Points,"moved/compared with different size"):-
    symbolic_operand_candidate(EA,Op_index,_,_),
    instruction_get_op(EA,Op_index,Op),
    op_immediate(Op,_),
    instruction_get_op(EA,_,Op2),
    op_indirect(Op2,_,_,_,_,_,Size),
    arch.pointer_size(Pt_size),
    Size/8 < Pt_size,
    heuristic_weight("moved/compared with different size",Points).

symbolic_operand_point(EA,Op_index,Points,"used-for-address"):-
    symbolic_operand_candidate(EA,Op_index,_,_),
    instruction_get_op(EA,Op_index,Op),
    op_immediate(Op,_),
    def_used_for_address(EA,_),
    heuristic_weight("used-for-address",Points).

symbolic_operand_total_points(EA,Operand,Points):-
    symbolic_operand_candidate(EA,Operand,_,_),
    Points = sum X:{symbolic_operand_point(EA,Operand,X,_)}.

symbolic_operand(EA,Op_index,Value,Type):-
    symbolic_operand_candidate(EA,Op_index,Value,Type),
    symbolic_operand_total_points(EA,Op_index,Points),
    Points >= 0.


///////////////////////////////
// label candidates before moving
.decl labeled_data_candidate(EA:address)

labeled_data_candidate(EA):-
    symbol(EA,_,_,_,_,_).

labeled_data_candidate(EA):-
    symbolic_operand(_,_,EA,"data").

labeled_data_candidate(Val):-
    address_in_data_refined(EA,Val),
    arch.pointer_size(Pt_size),
    EA % Pt_size = 0.

// Detect symbol-symbol
////////////////////////////////////////////////////////////////////////

// Symbol-Symbol candidate keeps track of which symbol is the reference and which is the target

symbol_minus_symbol_candidate(TableStart,Size,TableReference,Dest,"first"):-
    jump_table_start(_,Size,TableStart,TableReference,"ADD"),
    (
        Size > 1,data_word(TableStart,Size,Diff);
        Size = 1,data_byte(TableStart,Diff)
    ),
    Dest = TableReference + Diff,
    code(Dest).

symbol_minus_symbol_candidate(TableStart,Size,Dest,TableReference,"second"):-
    jump_table_start(_,Size,TableStart,TableReference,"SUB"),
    (
        Size > 1,data_word(TableStart,Size,Diff);
        Size = 1,data_byte(TableStart,Diff)
    ),
    Dest = TableReference - Diff,
    code(Dest).

symbol_minus_symbol_candidate(EA+Size,Size,Reference,Symbol,"first"):-
    symbol_minus_symbol_candidate(EA,Size,Reference,_,"first"),
    !jump_table_start(_,_,EA+Size,_,_),
    (
        Size>1,data_word(EA+Size,Size,Diff);
        Size=1,data_byte(EA+Size,Diff)
    ),
    Symbol = Reference + Diff,
    code(Symbol),
    preferred_data_access(EA+Size,Label),
    data_access_pattern(Label,Size,Size,_).

symbol_minus_symbol_candidate(EA+Size,Size,Symbol,Reference,"second"):-
    symbol_minus_symbol_candidate(EA,Size,_,Reference,"second"),
    !jump_table_start(_,_,EA+Size,_,_),
    (
        Size>1,data_word(EA+Size,Size,Diff);
        Size=1,data_byte(EA+Size,Diff)
    ),
    Symbol = Reference - Diff,
    code(Symbol),
    preferred_data_access(EA+Size,Label),
    data_access_pattern(Label,Size,Size,_).

////////////////////////////////////////////////////////////////////////
// address_in_data considers anything that points to the code region
// this refinement restricts that to the beginning of the final blocks
.decl address_in_data_refined(EA:address,Val:number)

address_in_data_refined(EA,Val):-
    binary_type("DYN"),
    address_in_data(EA,Val),
    relocation(EA,_,_,_),
    data_segment(Beg,End),
    Val >= Beg, Val <= End.

address_in_data_refined(EA,Val):-
    binary_type("DYN"),
    address_in_data(EA,Val),
    relocation(EA,_,_,_),
    block(Val).

address_in_data_refined(EA,Val):-
    binary_type("EXEC"),
    address_in_data(EA,Val),
    data_segment(Beg,End),
    Val >= Beg,
    Val <= End.
      
address_in_data_refined(EA,Val):-
    binary_type("EXEC"),
    address_in_data(EA,Val),
    block(Val).


.init address_in_data_refined_range=empty_range

address_in_data_refined_range.in_ea(EA):-
    address_in_data_refined(EA,_).
/////////////////////////////////////////////////////////////////////////////////
// Detect strings
string_candidate(Beg,End+1):-
    data_byte(End,0),
    string_part(End-1,Beg),
    !labeled_data_candidate(End).


.decl string_part(ea:address,base:address)

string_part(EA,EA):-
    preferred_data_access(EA,_),
    data_byte(EA,Byte),
    printable_char(Byte).

string_part(EA,EA):-
    labeled_data_candidate(EA),
    data_byte(EA,Byte),
    printable_char(Byte).

string_part(EA+1,Base):-
    string_part(EA,Base),
    data_byte(EA+1,Byte),
    !labeled_data_candidate(EA+1),
    printable_char(Byte).

///////////////////////////////////////////////////////////////////////////
.decl data_object_candidate(ea:address,size:number,type:symbol)

.decl data_object_point(ea:address,size:number,type:symbol,points:number,why:symbol)
.output data_object_point

.decl data_object_conflict(ea:address,size:number,type:symbol,ea2:address,size2:number,type2:symbol)
.output data_object_conflict

.decl discarded_data_object(ea:address,size:number,type:symbol)

.decl data_object(ea:address,size:number,type:symbol)

data_object_candidate(EA,Size,"symbol-symbol"):-
    symbol_minus_symbol_candidate(EA,Size,_,_,_).

data_object_candidate(EA,Pt_size,"symbol"):-
    arch.pointer_size(Pt_size),
    address_in_data_refined(EA,_).

data_object_candidate(EA,Size,"string"):-
    string_candidate(EA,End),
    Size = End-EA.

data_object_candidate(EA,Size,"other"):-
    preferred_data_access(EA,Label),
    data_access_pattern(Label,Size,_,_),
    Size != Pt_size,
    Size > 0,
    arch.pointer_size(Pt_size),
    !symbol_minus_symbol_candidate(EA,Size,_,_,_).

///////////////////////////////////////////////////////////////////////////////////////////
// Heuristic: If there are at least 3 consecutive addresses
//  we consider that we found an array of addresses
// we do not cross labels
.decl after_address_in_data(EA:address,EA_next:address)

after_address_in_data(EA,EA+Pt_size):-
    address_in_data_refined(EA,_),
    arch.pointer_size(Pt_size),
    data_byte(EA+Pt_size,_),
    !labeled_data_candidate(EA+Pt_size).

after_address_in_data(EA,EA_aux+1):-
    after_address_in_data(EA,EA_aux),
    !address_in_data_refined(EA_aux,_),
    data_byte(EA_aux+1,_),
    !labeled_data_candidate(EA_aux+1).

.decl next_address_in_data(EA:address,EA_next:address)


next_address_in_data(EA,EA_next):-
    address_in_data_refined(EA,_),
    after_address_in_data(EA,EA_next),
    address_in_data_refined(EA_next,_).


.decl address_array_aux(EA:address,Distance:number,type:symbol,InitialEA:address)

address_array_aux(EA,Diff,"code",EA):-
    address_in_data_refined(EA,Dest1),code(Dest1),
    arch.pointer_size(Pt_size),
    EA % Pt_size = 0,
    next_address_in_data(EA,EA_next),
    Diff = EA_next-EA,
    address_in_data_refined(EA+Diff,Dest2),code(Dest2),
    next_address_in_data(EA+Diff,EA+(2*Diff)),
    address_in_data_refined(EA+(2*Diff),Dest3),code(Dest3).


address_array_aux(EA,Diff,"data",EA):-
    address_in_data_refined(EA,Dest1),data_byte(Dest1,_),
    arch.pointer_size(Pt_size),
    EA % Pt_size = 0,
    next_address_in_data(EA,EA_next),
    Diff = EA_next-EA,
    address_in_data_refined(EA+Diff,Dest2),data_byte(Dest2,_),
    next_address_in_data(EA+Diff,EA+(2*Diff)),
    address_in_data_refined(EA+(2*Diff),Dest3),data_byte(Dest3,_),
    data_segment(Begin,End),
    // a pointer array pointing to data, should point to the same section
    Begin <= Dest1, Dest1 <= End,
    Begin <= Dest2, Dest2 <= End,
    Begin <= Dest3, Dest3 <= End.


address_array_aux(EA+Diff,Diff,"code",InitialEA):-
    address_array_aux(EA,Diff,"code",InitialEA),
    next_address_in_data(EA,EA+Diff),
    address_in_data_refined(EA+Diff,Dest),code(Dest).

address_array_aux(EA+Diff,Diff,"data",InitialEA):-
    address_array_aux(EA,Diff,"data",InitialEA),
    address_in_data_refined(EA,Dest1),
    next_address_in_data(EA,EA+Diff),
    address_in_data_refined(EA+Diff,Dest2),data_byte(Dest2,_),
    data_segment(Begin,End),
    // a pointer array pointing to data, should point to the same section
    Begin <= Dest1, Dest1 <= End,
    Begin <= Dest2, Dest2 <= End.

.decl address_array(EA:address,Distance:number,InitialEA:address)

address_array(EA,Distance,InitialEA):-
    address_array_aux(EA,Distance,_,InitialEA).

.init address_array_range=empty_range

address_array_range.in_ea(EA):-
    address_array(EA,_,_).


//////////////////////////////////////////////////////////////////////////////////
// Final decision on symbolization of data

default_heuristic_weight("pointer array",3).
default_heuristic_weight("data object bias",-2).
default_heuristic_weight("quad symbol-symbol",5).
default_heuristic_weight("symbol-symbol",4).
default_heuristic_weight("pointed by pointer array",2).
default_heuristic_weight("symbol data access",5).
default_heuristic_weight("multiple conflict",-2).
default_heuristic_weight("no label conflicts",1).
default_heuristic_weight("aligned",2).
default_heuristic_weight("point-to-exception-section",-2).
default_heuristic_weight("point-to-special-section",-1).
default_heuristic_weight("data has relocation",10).
default_heuristic_weight("string basic point",2).
default_heuristic_weight("long string",3).
default_heuristic_weight("string in jump table",-2).
default_heuristic_weight("data access",4).
default_heuristic_weight("data access xmm",1).

data_object_point(EA,Pt_size,Type,Points,"data object bias"):-
    data_object_candidate(EA,Pt_size,Type),
    heuristic_weight("data object bias",Points).

data_object_point(EA,8,"symbol-symbol",Points,"quad symbol-symbol"):-
    data_object_candidate(EA,8,"symbol-symbol"),
    heuristic_weight("quad symbol-symbol",Points).

data_object_point(EA,Size,"symbol-symbol",Points,"symbol-symbol"):-
    data_object_candidate(EA,Size,"symbol-symbol"),
    Size <= 4,
    heuristic_weight("symbol-symbol",Points).

// Pointer array heuristic
data_object_point(EA,Pt_size,"symbol",Points,"pointer array"):-
    data_object_candidate(EA,Pt_size,"symbol"),
    address_array(EA,_,_),
    heuristic_weight("pointer array",Points).

// a pointer array should point to the same type
data_object_point(EA,Size,Type,Points,"pointed by pointer array"),
data_object_point(EA2,Size2,Type,Points,"pointed by pointer array"),
data_object_point(EA3,Size3,Type,Points,"pointed by pointer array"),
data_object_point(EA4,Size4,Type,Points,"pointed by pointer array"):-
    address_array(EA_array,Distance,InitialEA),
    address_in_data(EA_array,EA),
    data_object_candidate(EA,Size,Type),

    address_array(EA_array+Distance,Distance,InitialEA),
    address_in_data(EA_array+Distance,EA2),
    data_object_candidate(EA2,Size2,Type),

    address_array(EA_array+2*Distance,Distance,InitialEA),
    address_in_data(EA_array+2*Distance,EA3),
    data_object_candidate(EA3,Size3,Type),

    address_array(EA_array+3*Distance,Distance,InitialEA),
    address_in_data(EA_array+3*Distance,EA4),
    data_object_candidate(EA4,Size4,Type),

    heuristic_weight("pointed by pointer array",Points).

// data access heuristic
data_object_point(EA,Pt_size,"symbol",Points,"symbol data access"):-
    data_object_candidate(EA,Pt_size,"symbol"),
    preferred_data_access(EA,Label),
    (
        data_access_pattern(Label,Pt_size,_,_);
        data_access_pattern(Label,0,_,_)
    ),
    heuristic_weight("symbol data access",Points).

// if we conflict with several other candidates we reduce the points
data_object_point(EA,Pt_size,"symbol",Points,"multiple conflict"):-
    data_object_candidate(EA,Pt_size,"symbol"),
    data_object_conflict(EA,Pt_size,"symbol",EA2,_,"other"),
    data_object_conflict(EA,Pt_size,"symbol",EA3,_,"other"),
    EA2 != EA3,
    heuristic_weight("multiple conflict",Points).

data_object_point(EA,Pt_size,"symbol",Points,"no label conflicts"):-
    data_object_candidate(EA,Pt_size,"symbol"),
    labeled_data_candidate(EA),
    !labeled_data_candidate(EA+1),
    !labeled_data_candidate(EA+2),
    !labeled_data_candidate(EA+3),
    !labeled_data_candidate(EA+4),
    !labeled_data_candidate(EA+5),
    !labeled_data_candidate(EA+6),
    !labeled_data_candidate(EA+7),
    heuristic_weight("no label conflicts",Points).

data_object_point(EA,Pt_size,"symbol",Points,"aligned"):-
    data_object_candidate(EA,Pt_size,"symbol"),
    EA % Pt_size = 0,
    heuristic_weight("aligned",Points).

data_object_point(EA,Pt_size,"symbol",Points,"point-to-exception-section"):-
    data_object_candidate(EA,Pt_size,"symbol"),
    address_in_data_refined(EA,Dest),
    exception_section(Name),
    section(Name,SectSize,Base),
    Dest >= Base, Dest < Base+SectSize,
    heuristic_weight("point-to-exception-section",Points).

data_object_point(EA,Pt_size,"symbol",Points,"point-to-special-section"):-
    data_object_candidate(EA,Pt_size,"symbol"),
    address_in_data_refined(EA,Dest),
    special_data_section(Name),
    section(Name,SectSize,Base),
    Dest >= Base, Dest < Base+SectSize,
    heuristic_weight("point-to-special-section",Points).


data_object_point(EA,Pt_size,"symbol",Points,"data has relocation"):-
    !binary_type("EXEC"),
    data_object_candidate(EA,Pt_size,"symbol"),
    relocation(EA,_,_,_),
    heuristic_weight("data has relocation",Points).

//extra point if the string is long
data_object_point(EA,Size,"string",Points,"string basic point"):-
    heuristic_weight("string basic point",Points),
    data_object_candidate(EA,Size,"string").

data_object_point(EA,Size,"string",Points,"long string"):-
    data_object_candidate(EA,Size,"string"),
    Size > 5,
    heuristic_weight("long string",Points).

data_object_point(EA,Size,"string",Points,"string in jump table"):-
    data_object_candidate(EA,Size,"string"),
    preferred_data_access(EA,EA_ref),
    jump_table_start(_,_,EA_ref,_,_),
    heuristic_weight("string in jump table",Points).

// data access negative heuristic
data_object_point(EA,Size,"other",Points,"data access"):-
    data_object_candidate(EA,Size,"other"),
    Size < 16,
    heuristic_weight("data access",Points).

//sometimes we load pointers into xmm
data_object_point(EA,Size,"other",Points,"data access xmm"):-
    data_object_candidate(EA,Size,"other"),
    Size >= 16,
    heuristic_weight("data access xmm",Points).

//range mismatch
data_object_conflict(EA,Size,Type,EA2,Size2,Type2):-
    data_object_candidate(EA,Size,Type),
    data_object_candidate(EA2,Size2,Type2),
    EA2 > EA,
    EA2 < EA+Size.

//size mismatch
data_object_conflict(EA,Size,Type,EA,Size2,Type2):-
    data_object_candidate(EA,Size,Type),
    data_object_candidate(EA,Size2,Type2),
    Size2 > Size.

//type mismatch
data_object_conflict(EA,Size,Type,EA,Size,Type2):-
    data_object_candidate(EA,Size,Type),
    data_object_candidate(EA,Size,Type2),
    Type != Type2.

.decl data_object_total_points(EA:address,Size:number,Type:symbol,Points:number)
.output data_object_total_points

data_object_total_points(EA,Size,Type,Points):-
    data_object_candidate(EA,Size,Type),
    Points = sum X:{data_object_point(EA,Size,Type,X,_)}.

data_object(EA,Size,Type):-
    data_object_total_points(EA,Size,Type,Points),
    !discarded_data_object(EA,Size,Type),
    Points >= 0.

discarded_data_object(EA_f,Size_f,Type_f):-
    data_object_conflict(EA,Size,Type,EA2,Size2,Type2),
    data_object_total_points(EA,Size,Type,Points1),
    data_object_total_points(EA2,Size2,Type2,Points2),
    (
        Points1 < Points2,
        EA_f = EA,
        Size_f = Size,
        Type_f = Type
        ;
        Points1 > Points2,
        EA_f = EA2,
        Size_f = Size2,
        Type_f = Type2
    ).

// predicates to export

symbolic_data(EA,Size,Val):-
    data_object(EA,Size,"symbol"),
    address_in_data_refined(EA,Val).

string(EA,End):-
    data_object(EA,Size,"string"),
    string_candidate(EA,End),
    Size = End-EA.

symbol_minus_symbol(EA,Size,Symbol1,Symbol2):-
    data_object(EA,Size,"symbol-symbol"),
    symbol_minus_symbol_candidate(EA,Size,Symbol1,Symbol2,_).

code_pointer_in_data(EA,Val):-
    symbolic_data(EA,_,Val),
    block(Val).

///////////////////////////////////////////////////////////////////////////////////////////
// Final label decision

labeled_data(EA):-
    symbol(EA,_,_,_,_,_).

labeled_data(EA):-
    symbolic_operand(Src,_,EA,"data"),
    !moved_label(Src,_,EA,_).

labeled_data(EA):-
    address_in_data_refined(Src,EA),
    !moved_data_label(Src,_,EA,_).

labeled_data(EA_moved):-
    moved_label(_,_,_,EA_moved).

labeled_data(New_dest):-
    moved_data_label(_,_,_,New_dest).

labeled_data(EA):-
    symbol_minus_symbol(EA,_,EA,_).
/////////////////////////////////////////////////////////////////////////////////
// This facts specifies that a label should be printed in the .bss section for
// the given address (because it is referenced somewhere)

bss_data(Base),
bss_data(Base+SizeSect):-
    bss_section(SectionName),
    section(SectionName,SizeSect,Base).

bss_data(EA):-
    labeled_data(EA),
    bss_section(SectionName),
    section(SectionName,SizeSect,Base),
    EA >= Base,
    EA < Base+SizeSect.